<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Audio HF receiver</title>
    <style>
        body {
            font-family: sans-serif;
            padding: 16px;
            background-color: #010;
            color: #eee;
        }

        .channel {
            margin-bottom: 10px;
        }

        canvas {
            width: 100%;
            height: 256px;
            background: #121;
        }
    </style>
</head>

<body>
    <h1>Audio HF receiver</h1>
    <button id="start">Start</button>

    <div id="channels"></div>

    <canvas id="spectrumCanvas"></canvas>
    <canvas id="spectrumCanvas2"></canvas>

    <script type="module">
        let context, source, analyser, analyserAfter;
        let bufferLength;
        let dataArray;
        let dataArrayAfter;

        const startBtn = document.getElementById('start');
        const channelContainer = document.getElementById('channels');
        const canvas = document.getElementById('spectrumCanvas');
        const canvas2 = document.getElementById('spectrumCanvas2');
        const canvasCtx = canvas.getContext('2d');
        const canvasCtx2 = canvas2.getContext('2d');

        canvas.height = 256;
        canvas2.height = 256;

        const channels = [
            //{name: '8–11 кГц', shift: 8000},
            //{name: '11–14 кГц', shift: 11000},
            {name: '14–17 кГц', shift: 14000},
            {name: '17–20 кГц', shift: 17000},
            {name: '20–24 кГц', shift: 20000}
        ];

        let nodes = [];


        function createSuperBrickWallFilter(context, lowFreq, highFreq) {
            // Highpass часть (4 фильтра)
            const hp1 = context.createBiquadFilter();
            hp1.type = "highpass";
            hp1.frequency.value = lowFreq;
            hp1.Q.value = 5;

            const hp2 = context.createBiquadFilter();
            hp2.type = "highpass";
            hp2.frequency.value = lowFreq;
            hp2.Q.value = 5;

            const hp3 = context.createBiquadFilter();
            hp3.type = "highpass";
            hp3.frequency.value = lowFreq;
            hp3.Q.value = 5;

            const hp4 = context.createBiquadFilter();
            hp4.type = "highpass";
            hp4.frequency.value = lowFreq;
            hp4.Q.value = 5;

            // Lowpass часть (4 фильтра)
            const lp1 = context.createBiquadFilter();
            lp1.type = "lowpass";
            lp1.frequency.value = highFreq;
            lp1.Q.value = 5;

            const lp2 = context.createBiquadFilter();
            lp2.type = "lowpass";
            lp2.frequency.value = highFreq;
            lp2.Q.value = 5;

            const lp3 = context.createBiquadFilter();
            lp3.type = "lowpass";
            lp3.frequency.value = highFreq;
            lp3.Q.value = 5;

            const lp4 = context.createBiquadFilter();
            lp4.type = "lowpass";
            lp4.frequency.value = highFreq;
            lp4.Q.value = 5;

            // Notch фильтры на границах
            const notchLow = context.createBiquadFilter();
            notchLow.type = "notch";
            notchLow.frequency.value = lowFreq - 10;
            notchLow.Q.value = 30;

            const notchHigh = context.createBiquadFilter();
            notchHigh.type = "notch";
            notchHigh.frequency.value = highFreq + 10;
            notchHigh.Q.value = 30;

            // Собираем цепочку
            hp1.connect(hp2)
                .connect(hp3)
                .connect(hp4)
                .connect(lp1)
                .connect(lp2)
                .connect(lp3)
                .connect(lp4)
                .connect(notchLow)
                .connect(notchHigh);

            return {
                input: hp1,
                output: notchHigh,
            };
        }


        // Создание канала
        function createChannel(channel) {
            const bw1 = createSuperBrickWallFilter(context, channel.shift, channel.shift + 3000);
            const lowpass = createSuperBrickWallFilter(context, 0, 3000);

            // 2. Создаем гетеродин (осциллятор для смещения частоты)
            const oscillator = context.createOscillator();
            oscillator.type = 'sine';
            oscillator.frequency.value = channel.shift; // На сколько смещаем (16 кГц → 0 Гц)
            oscillator.start();

            // 3. Создаем умножитель (гетеродинное преобразование)
            const multiplier = context.createGain();
            multiplier.gain.value = 2; // Коэффициент усиления

            bw1.output.connect(multiplier);

            // Гетеродин → Умножитель
            oscillator.connect(multiplier.gain); // Модулируем gain осциллятором

            // Умножитель → Фильтр → Выход
            multiplier.connect(lowpass.input)
            lowpass.output.connect(analyserAfter).connect(context.destination);
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.addEventListener('change', () => {
                if (checkbox.checked) source.connect(bw1.input);
                else source.disconnect(bw1.input);
            });

            const label = document.createElement('label');
            label.textContent = ` ${channel.name}`;
            const div = document.createElement('div');
            div.className = 'channel';
            label.prepend(checkbox);
            div.appendChild(label);
            channelContainer.appendChild(div);

            return bw1;
        }

        // Визуализация
        function draw() {
            requestAnimationFrame(draw);
            analyser.getByteFrequencyData(dataArray);
            analyserAfter.getByteFrequencyData(dataArrayAfter);

            canvasCtx.fillStyle = '#121';
            canvasCtx.fillRect(0, 0, canvas.width, canvas.height);

            for (let i = 0; i < bufferLength; i++) {
                const barHeight = dataArray[i];
                canvasCtx.fillStyle = `rgb(50, ${barHeight + 100}, 50)`;
                canvasCtx.fillRect(i, canvas.height - barHeight, 1, barHeight);
            }


            canvasCtx2.fillStyle = '#121';
            canvasCtx2.fillRect(0, 0, canvas2.width, canvas2.height);

            for (let i = 0; i < bufferLength; i++) {
                const barHeight = dataArrayAfter[i];
                canvasCtx2.fillStyle = `rgb(50, ${barHeight + 100},50)`;
                canvasCtx2.fillRect(i, canvas2.height - barHeight, 1, barHeight);
            }
        }

        async function getBestMicrophone() {
            try {
                // Запрашиваем разрешение на доступ к устройствам
                const devices = await navigator.mediaDevices.enumerateDevices();

                // Фильтруем только аудиовходные устройства (микрофоны)
                const microphones = devices.filter(device =>
                    device.kind === 'audioinput' && device.deviceId !== 'default');

                if (microphones.length === 0) {
                    console.warn('Микрофоны не найдены');
                    return null;
                }

                // Стратегии выбора:
                // 1. Попробовать найти устройство с "лучшими" характеристиками в имени
                const preferredNames = ['studio', 'pro', 'external', 'usb', 'hd'];
                const found = microphones.find(mic =>
                    preferredNames.some(name => mic.label.toLowerCase().includes(name)));

                if (found) return found;

                // 2. Выбрать не-default устройство (часто default - встроенный микрофон)
                const nonDefault = microphones.find(mic => !mic.label.includes('Default'));
                if (nonDefault) return nonDefault;

                // 3. Вернуть первое доступное
                return microphones[0];

            } catch (error) {
                console.error('Ошибка при получении устройств:', error);
                return null;
            }
        }

        startBtn.addEventListener('click', async () => {
            try {
                context = new AudioContext({
                    // latencyHint: "balanced",
                    sampleRate: 48000,
                });

                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        sampleRate: 48000,
                        deviceId: (await getBestMicrophone())?.deviceId,
                    }
                });

                // Анализатор
                analyser = context.createAnalyser();
                analyser.fftSize = 2048;
                analyser.minDecibels = -125;
                analyserAfter = context.createAnalyser();
                analyserAfter.fftSize = 2048;
                analyserAfter.minDecibels = -125;

                canvas.width = analyser.frequencyBinCount;
                canvas2.width = analyser.frequencyBinCount;

                source = context.createMediaStreamSource(stream);
                source.connect(analyser);

                nodes = channels.map(ch => createChannel(ch));

                bufferLength = analyser.frequencyBinCount;
                dataArray = new Uint8Array(bufferLength);
                dataArrayAfter = new Uint8Array(bufferLength);

                draw(); // Запуск визуализации
            } catch (err) {
                console.error("Ошибка:", err);
            }
        });
    </script>
</body>

</html>
