<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Audio HF Receiver</title>
    <style>
        body {
            font-family: sans-serif;
            padding: 16px;
            background-color: #010;
            color: #eee;
        }

        .channel {
            margin-bottom: 10px;
        }

        canvas {
            width: 100%;
            height: 256px;
            background: #121;
            display: block;
            margin-bottom: 12px;
        }

        button {
            margin-right: 10px;
            padding: 8px 16px;
            font-size: 1rem;
            cursor: pointer;
            background: #2a2;
            border: none;
            color: white;
            border-radius: 4px;
        }

        button:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }

        #status {
            margin-top: 10px;
            font-style: italic;
            color: #6f6;
        }

        label {
            user-select: none;
        }
    </style>
</head>

<body>
    <h1>Audio HF Receiver</h1>
    <button id="start">Start</button>
    <button id="stop" disabled>Stop</button>
    <div id="status">Stopped</div>

    <div id="channels"></div>

    <canvas id="spectrumCanvas"></canvas>
    <canvas id="spectrumCanvas2"></canvas>

    <script type="module">
        let context = null;
        let source = null;
        let analyser = null;
        let analyserAfter = null;
        let bufferLength = 0;
        let dataArray = null;
        let dataArrayAfter = null;
        let animationId = null;

        const startBtn = document.getElementById('start');
        const stopBtn = document.getElementById('stop');
        const statusEl = document.getElementById('status');
        const channelContainer = document.getElementById('channels');
        const canvas = document.getElementById('spectrumCanvas');
        const canvas2 = document.getElementById('spectrumCanvas2');
        const canvasCtx = canvas.getContext('2d');
        const canvasCtx2 = canvas2.getContext('2d');

        canvas.height = 256;
        canvas2.height = 256;

        const channels = [
            { name: '12–15 кГц', shift: 12000 },
            { name: '15–18 кГц', shift: 15000 },
            { name: '18–21 кГц', shift: 18000 },
            { name: '21–24 кГц', shift: 21000 }
        ];

        const checkboxes = [];
        const nodes = [];

        // Определение мобильного устройства
        function isMobileDevice() {
            return /android|iphone|ipad|ipod|mobile|blackberry|windows phone/i.test(navigator.userAgent);
        }

        function createSuperBrickWallFilter(context, lowFreq, highFreq) {
            const hpFilters = [];
            const lpFilters = [];

            for (let i = 0; i < 4; i++) {
                const hp = context.createBiquadFilter();
                hp.type = "highpass";
                hp.frequency.value = lowFreq;
                hp.Q.value = 2;
                hpFilters.push(hp);

                const lp = context.createBiquadFilter();
                lp.type = "lowpass";
                lp.frequency.value = highFreq;
                lp.Q.value = 2;
                lpFilters.push(lp);
            }

            const notchLow = context.createBiquadFilter();
            notchLow.type = "notch";
            notchLow.frequency.value = lowFreq - 10;
            notchLow.Q.value = 30;

            const notchHigh = context.createBiquadFilter();
            notchHigh.type = "notch";
            notchHigh.frequency.value = highFreq + 10;
            notchHigh.Q.value = 30;

            for (let i = 0; i < hpFilters.length - 1; i++) {
                hpFilters[i].connect(hpFilters[i + 1]);
            }
            hpFilters[hpFilters.length - 1].connect(lpFilters[0]);

            for (let i = 0; i < lpFilters.length - 1; i++) {
                lpFilters[i].connect(lpFilters[i + 1]);
            }
            lpFilters[lpFilters.length - 1].connect(notchLow);
            notchLow.connect(notchHigh);

            return { input: hpFilters[0], output: notchHigh };
        }

        function createChannel(channel) {
            const bwFilter = createSuperBrickWallFilter(context, channel.shift, channel.shift + 3000);
            const lowpass = createSuperBrickWallFilter(context, 0, 3000);

            const oscillator = context.createOscillator();
            oscillator.type = 'sine';
            oscillator.frequency.value = channel.shift;
            oscillator.start();

            const multiplier = context.createGain();
            multiplier.gain.value = 2;

            bwFilter.output.connect(multiplier);
            oscillator.connect(multiplier.gain);
            multiplier.connect(lowpass.input);
            lowpass.output.connect(analyserAfter);
            analyserAfter.connect(context.destination);

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.disabled = true;
            checkbox.addEventListener('change', () => {
                checkbox.checked ? source.connect(bwFilter.input) : source.disconnect(bwFilter.input);
            });

            const label = document.createElement('label');
            label.textContent = ` ${channel.name}`;
            label.prepend(checkbox);

            const div = document.createElement('div');
            div.className = 'channel';
            div.appendChild(label);
            channelContainer.appendChild(div);

            checkboxes.push(checkbox);

            return { bwFilter, oscillator, multiplier, lowpass };
        }

        // Улучшенная отрисовка с градиентом и пиками
        function drawSpectrum(dataArray, ctx, canvas) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Градиентный фон
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, 'rgba(0, 150, 0, 0.2)');
            gradient.addColorStop(1, 'rgba(0, 50, 0, 0.5)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const barWidth = canvas.width / bufferLength;
            let maxValue = 0;

            // Рисуем бары
            for (let i = 0; i < bufferLength; i++) {
                const value = dataArray[i];
                const height = value * 1.5;
                
                // Градиент для баров
                const barGradient = ctx.createLinearGradient(0, canvas.height - height, 0, canvas.height);
                barGradient.addColorStop(0, '#0f0');
                barGradient.addColorStop(0.7, '#ff0');
                barGradient.addColorStop(1, '#f00');
                
                ctx.fillStyle = barGradient;
                ctx.fillRect(i * barWidth, canvas.height - height, barWidth, height);

                if (value > maxValue) maxValue = value;
            }

            // Рисуем пиковую линию
            ctx.strokeStyle = '#fff';
            ctx.beginPath();
            ctx.moveTo(0, canvas.height - maxValue * 1.5);
            ctx.lineTo(canvas.width, canvas.height - maxValue * 1.5);
            ctx.stroke();
        }

        async function getBestMicrophone() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const microphones = devices.filter(d => d.kind === 'audioinput' && d.deviceId !== 'default');
                
                const preferred = ['studio', 'pro', 'external', 'usb', 'hd'];
                return microphones.find(mic => preferred.some(p => mic.label.toLowerCase().includes(p))) 
                    || microphones[0];
            } catch (error) {
                console.error('Ошибка получения устройств:', error);
                return null;
            }
        }

        async function startAudio() {
            if (context) return;

            try {
                statusEl.textContent = 'Initializing...';
                startBtn.disabled = true;

                context = new AudioContext({ sampleRate: 48000 });
                const fftSize = isMobileDevice() ? 1024 : 2048;

                const mic = await getBestMicrophone();
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        sampleRate: 48000,
                        deviceId: mic?.deviceId || undefined,
                    }
                });

                analyser = context.createAnalyser();
                analyser.fftSize = fftSize;
                analyser.minDecibels = -125;

                analyserAfter = context.createAnalyser();
                analyserAfter.fftSize = fftSize;
                analyserAfter.minDecibels = -125;

                bufferLength = analyser.frequencyBinCount;
                dataArray = new Uint8Array(bufferLength);
                dataArrayAfter = new Uint8Array(bufferLength);

                canvas.width = bufferLength;
                canvas2.width = bufferLength;

                source = context.createMediaStreamSource(stream);
                source.connect(analyser);

                channelContainer.innerHTML = '';
                checkboxes.length = 0;
                nodes.length = 0;

                channels.forEach(channel => nodes.push(createChannel(channel)));
                checkboxes.forEach(cb => cb.disabled = false);

                function render() {
                    animationId = requestAnimationFrame(render);
                    
                    analyser.getByteFrequencyData(dataArray);
                    analyserAfter.getByteFrequencyData(dataArrayAfter);

                    drawSpectrum(dataArray, canvasCtx, canvas);
                    drawSpectrum(dataArrayAfter, canvasCtx2, canvas2);
                }
                render();

                statusEl.textContent = 'Running...';
                stopBtn.disabled = false;

            } catch (err) {
                console.error("Ошибка запуска:", err);
                statusEl.textContent = `Error: ${err.message}`;
                startBtn.disabled = false;
                
                if (err.name === 'NotAllowedError') {
                    alert('Требуется разрешение на использование микрофона!');
                }
            }
        }

        function stopAudio() {
            cancelAnimationFrame(animationId);
            
            [source, analyser, analyserAfter, context].forEach(node => {
                if (node) try { node.disconnect(); } catch {}
                if (node instanceof AudioContext) node.close();
            });

            context = null;
            checkboxes.forEach(cb => {
                cb.checked = false;
                cb.disabled = true;
            });

            channelContainer.innerHTML = '';
            startBtn.disabled = false;
            stopBtn.disabled = true;
            statusEl.textContent = 'Stopped';

            // Очистка канвасов
            canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
            canvasCtx2.clearRect(0, 0, canvas2.width, canvas2.height);
        }

        startBtn.addEventListener('click', startAudio);
        stopBtn.addEventListener('click', stopAudio);

        // Автоматический ресайз для мобильных устройств
        window.addEventListener('resize', () => {
            if (analyser) {
                canvas.width = analyser.frequencyBinCount;
                canvas2.width = analyser.frequencyBinCount;
            }
        });
    </script>
</body>

</html>

