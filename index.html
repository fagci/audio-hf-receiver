<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Audio HF Receiver</title>
    <style>
        body {
            font-family: sans-serif;
            padding: 16px;
            background-color: #010;
            color: #eee;
        }

        .channel {
            margin-bottom: 10px;
        }

        canvas {
            width: 100%;
            height: 256px;
            background: #121;
            display: block;
            margin-bottom: 12px;
        }

        button {
            margin-right: 10px;
            padding: 8px 16px;
            font-size: 1rem;
            cursor: pointer;
            background: #2a2;
            border: none;
            color: white;
            border-radius: 4px;
        }

        button:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }

        #status {
            margin-top: 10px;
            font-style: italic;
            color: #6f6;
        }

        label {
            user-select: none;
        }
    </style>
</head>

<body>
    <h1>Audio HF Receiver</h1>
    <button id="start">Start</button>
    <button id="stop" disabled>Stop</button>
    <div id="status">Stopped</div>

    <div id="channels"></div>

    <canvas id="spectrumCanvas"></canvas>
    <canvas id="waterfallCanvas"></canvas>

    <script type="module" src="spectrum.js"></script>
    <script type="module" src="waterfall.js"></script>

    <script type="module">
        let context = null;
        let source = null;
        let analyser = null;
        let bufferLength = 0;
        let dataArray;
        let animationId = null;

        import Spectrum from './spectrum.js'
        import Waterfall from './waterfall.js'

        const startBtn = document.getElementById('start');
        const stopBtn = document.getElementById('stop');
        const statusEl = document.getElementById('status');
        const channelContainer = document.getElementById('channels');

        const spectrumCanvas = document.getElementById('spectrumCanvas');
        const waterfallCanvas = document.getElementById('waterfallCanvas');

        let spectrum;
        let waterfall;

        const channels = [
            {name: '12–15 кГц', shift: 12000},
            {name: '15–18 кГц', shift: 15000},
            {name: '18–21 кГц', shift: 18000},
            {name: '21–24 кГц', shift: 21000},
            {name: '24-27 кГц', shift: 24000},
        ];

        const checkboxes = [];
        const nodes = [];

        // Определение мобильного устройства
        function isMobileDevice() {
            return /android|iphone|ipad|ipod|mobile|blackberry|windows phone/i.test(navigator.userAgent);
        }

        function x2f(x) {
            return x * context.sampleRate / (dataArray.length * 2)
        }

        function f2x(f) {
            return f / (context.sampleRate / (dataArray.length * 2))
        }


        function createSuperBrickWallFilter(context, lowFreq, highFreq) {
            const hpFilters = [];
            const lpFilters = [];

            for (let i = 0; i < 4; i++) {
                const hp = context.createBiquadFilter();
                hp.type = "highpass";
                hp.frequency.value = lowFreq;
                hp.Q.value = 2;
                hpFilters.push(hp);

                const lp = context.createBiquadFilter();
                lp.type = "lowpass";
                lp.frequency.value = highFreq;
                lp.Q.value = 2;
                lpFilters.push(lp);
            }

            const notchLow = context.createBiquadFilter();
            notchLow.type = "notch";
            notchLow.frequency.value = lowFreq - 10;
            notchLow.Q.value = 30;

            const notchHigh = context.createBiquadFilter();
            notchHigh.type = "notch";
            notchHigh.frequency.value = highFreq + 10;
            notchHigh.Q.value = 30;

            for (let i = 0; i < hpFilters.length - 1; i++) {
                hpFilters[i].connect(hpFilters[i + 1]);
            }
            hpFilters[hpFilters.length - 1].connect(lpFilters[0]);

            for (let i = 0; i < lpFilters.length - 1; i++) {
                lpFilters[i].connect(lpFilters[i + 1]);
            }
            lpFilters[lpFilters.length - 1].connect(notchLow);
            notchLow.connect(notchHigh);

            return {input: hpFilters[0], output: notchHigh};
        }

        function createChannel(channel) {
            const bwFilter = createSuperBrickWallFilter(context, channel.shift, channel.shift + 3000);
            const lowpass = createSuperBrickWallFilter(context, 0, 3000);

            const oscillator = context.createOscillator();
            oscillator.type = 'sine';
            oscillator.frequency.value = channel.shift;
            oscillator.start();

            const multiplier = context.createGain();
            multiplier.gain.value = 2;

            bwFilter.output.connect(multiplier);
            oscillator.connect(multiplier.gain);
            multiplier.connect(lowpass.input);
            lowpass.output.connect(context.destination);

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.disabled = true;
            checkbox.addEventListener('change', () => {
                checkbox.checked ? source.connect(bwFilter.input) : source.disconnect(bwFilter.input);
                const sx = f2x(channel.shift);
                const ex = f2x(channel.shift + 3000);

                checkbox.checked ? spectrum.addBw(sx, ex) : spectrum.removeBw(sx, ex);
            });

            const label = document.createElement('label');
            label.textContent = ` ${channel.name}`;
            label.prepend(checkbox);

            const div = document.createElement('div');
            div.className = 'channel';
            div.appendChild(label);
            channelContainer.appendChild(div);

            checkboxes.push(checkbox);

            return {bwFilter, oscillator, multiplier, lowpass};
        }

        async function getBestMicrophone() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const microphones = devices.filter(d => d.kind === 'audioinput' && d.deviceId !== 'default');

                const preferred = ['studio', 'pro', 'external', 'usb', 'hd'];
                return microphones.find(mic => preferred.some(p => mic.label.toLowerCase().includes(p)))
                    || microphones[0];
            } catch (error) {
                console.error('Ошибка получения устройств:', error);
                return null;
            }
        }

        function render() {
            requestAnimationFrame(render);
            analyser.getByteFrequencyData(dataArray);

            spectrum.update();
            waterfall.update();

            spectrum.render();
            waterfall.render();
        }

        async function startAudio() {
            if (context) return;

            try {
                statusEl.textContent = 'Initializing...';
                startBtn.disabled = true;

                context = new AudioContext({sampleRate: 48000 * 2});
                console.log(context.sampleRate);
                const fftSize = isMobileDevice() ? 1024 : 2048;

                const mic = await getBestMicrophone();
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        // echoCancellation: false,
                        // noiseSuppression: false,
                        sampleRate: 48000 * 2,
                        // deviceId: mic?.deviceId || undefined,
                    }
                });

                analyser = context.createAnalyser();
                analyser.fftSize = fftSize;
                analyser.smoothingTimeConstant = 0.1;
                analyser.minDecibels = -125;

                dataArray = new Uint8Array(analyser.frequencyBinCount);

                spectrum = new Spectrum(spectrumCanvas, dataArray, 0, 255);
                waterfall = new Waterfall(waterfallCanvas, dataArray, 0, 255);

                for (let i = 24000; i < 100000; i += 24000) {
                    spectrum.addBw(f2x(i), f2x(i));
                }

                source = context.createMediaStreamSource(stream);
                source.connect(analyser);

                channelContainer.innerHTML = '';
                checkboxes.length = 0;
                nodes.length = 0;

                channels.forEach(channel => nodes.push(createChannel(channel)));
                checkboxes.forEach(cb => cb.disabled = false);


                statusEl.textContent = 'Running...';
                stopBtn.disabled = false;

                render();
            } catch (err) {
                console.error("Ошибка запуска:", err);
                statusEl.textContent = `Error: ${err.message}`;
                startBtn.disabled = false;

                if (err.name === 'NotAllowedError') {
                    alert('Требуется разрешение на использование микрофона!');
                }
            }
        }

        function stopAudio() {
            cancelAnimationFrame(animationId);

            [source, analyser, context].forEach(node => {
                if (node) try {node.disconnect();} catch { }
                if (node instanceof AudioContext) node.close();
            });

            context = null;
            checkboxes.forEach(cb => {
                cb.checked = false;
                cb.disabled = true;
            });

            channelContainer.innerHTML = '';
            startBtn.disabled = false;
            stopBtn.disabled = true;
            statusEl.textContent = 'Stopped';
        }

        startBtn.addEventListener('click', startAudio);
        stopBtn.addEventListener('click', stopAudio);
    </script>
</body>

</html>
