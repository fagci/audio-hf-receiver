<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Audio HF Receiver</title>
    <style>
        body {
            font-family: sans-serif;
            padding: 16px;
            background-color: #010;
            color: #eee;
        }

        .channel {
            margin-bottom: 10px;
        }

        canvas {
            width: 100%;
            height: 256px;
            background: #121;
            display: block;
            margin-bottom: 12px;
        }

        button {
            margin-right: 10px;
            padding: 8px 16px;
            font-size: 1rem;
            cursor: pointer;
        }

        #status {
            margin-top: 10px;
            font-style: italic;
            color: #6f6;
        }
    </style>
</head>

<body>
    <h1>Audio HF Receiver</h1>
    <button id="start">Start</button>
    <button id="stop" disabled>Stop</button>
    <div id="status">Stopped</div>

    <div id="channels"></div>

    <canvas id="spectrumCanvas"></canvas>
    <canvas id="spectrumCanvas2"></canvas>

    <script type="module">
        let context;
        let source;
        let analyser;
        let analyserAfter;
        let bufferLength;
        let dataArray;
        let dataArrayAfter;
        let animationId;

        const startBtn = document.getElementById('start');
        const stopBtn = document.getElementById('stop');
        const statusEl = document.getElementById('status');
        const channelContainer = document.getElementById('channels');
        const canvas = document.getElementById('spectrumCanvas');
        const canvas2 = document.getElementById('spectrumCanvas2');
        const canvasCtx = canvas.getContext('2d');
        const canvasCtx2 = canvas2.getContext('2d');

        // Высота канваса фиксирована, ширина будет установлена после инициализации анализатора
        canvas.height = 256;
        canvas2.height = 256;

        const channels = [
            {name: '12–15 кГц', shift: 12000},
            {name: '15–18 кГц', shift: 15000},
            {name: '18–21 кГц', shift: 18000},
            {name: '21–24 кГц', shift: 21000}
        ];

        let nodes = [];
        let checkboxes = [];

        // Создаём фильтр "Super Brickwall" с 4 HPF и 4 LPF + notch на границах
        function createSuperBrickWallFilter(context, lowFreq, highFreq) {
            const hpFilters = [];
            const lpFilters = [];

            for (let i = 0; i < 4; i++) {
                const hp = context.createBiquadFilter();
                hp.type = "highpass";
                hp.frequency.value = lowFreq;
                hp.Q.value = 2;
                hpFilters.push(hp);

                const lp = context.createBiquadFilter();
                lp.type = "lowpass";
                lp.frequency.value = highFreq;
                lp.Q.value = 2;
                lpFilters.push(lp);
            }

            const notchLow = context.createBiquadFilter();
            notchLow.type = "notch";
            notchLow.frequency.value = lowFreq - 10;
            notchLow.Q.value = 30;

            const notchHigh = context.createBiquadFilter();
            notchHigh.type = "notch";
            notchHigh.frequency.value = highFreq + 10;
            notchHigh.Q.value = 30;

            // Соединяем фильтры в цепочку: HPF цепочка → LPF цепочка → Notch Low → Notch High
            for (let i = 0; i < hpFilters.length - 1; i++) {
                hpFilters[i].connect(hpFilters[i + 1]);
            }
            hpFilters[hpFilters.length - 1].connect(lpFilters[0]);

            for (let i = 0; i < lpFilters.length - 1; i++) {
                lpFilters[i].connect(lpFilters[i + 1]);
            }
            lpFilters[lpFilters.length - 1].connect(notchLow);
            notchLow.connect(notchHigh);

            return {
                input: hpFilters[0],
                output: notchHigh,
            };
        }

        // Создание одного канала с гетеродином и фильтрами
        function createChannel(channel) {
            const bwFilter = createSuperBrickWallFilter(context, channel.shift, channel.shift + 3000);
            const lowpass = createSuperBrickWallFilter(context, 0, 3000);

            // Создаём осциллятор для гетеродина
            const oscillator = context.createOscillator();
            oscillator.type = 'sine';
            oscillator.frequency.value = channel.shift;
            oscillator.start();

            // Умножитель (модуляция)
            const multiplier = context.createGain();
            multiplier.gain.value = 2;

            // Подключаем цепочку: фильтр BW → умножитель
            bwFilter.output.connect(multiplier);

            // Осциллятор модулирует gain умножителя (гетеродинное смещение)
            oscillator.connect(multiplier.gain);

            // Умножитель → низкочастотный фильтр → анализатор → выход
            multiplier.connect(lowpass.input);
            lowpass.output.connect(analyserAfter);
            analyserAfter.connect(context.destination);

            // Создаём чекбокс для включения/выключения канала
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.disabled = true; // Активируем после запуска аудио
            checkbox.addEventListener('change', () => {
                if (checkbox.checked) {
                    source.connect(bwFilter.input);
                } else {
                    try {
                        source.disconnect(bwFilter.input);
                    } catch { /* Игнорируем ошибки при отключении */}
                }
            });

            const label = document.createElement('label');
            label.textContent = ` ${channel.name}`;
            label.prepend(checkbox);

            const div = document.createElement('div');
            div.className = 'channel';
            div.appendChild(label);
            channelContainer.appendChild(div);

            checkboxes.push(checkbox);

            return bwFilter;
        }

        // Визуализация спектра
        function draw() {
            animationId = requestAnimationFrame(draw);

            analyser.getByteFrequencyData(dataArray);
            analyserAfter.getByteFrequencyData(dataArrayAfter);

            // Очистка и отрисовка первого спектра
            canvasCtx.fillStyle = '#121';
            canvasCtx.fillRect(0, 0, canvas.width, canvas.height);

            const barWidth = canvas.width / bufferLength;

            for (let i = 0; i < bufferLength; i++) {
                const barHeight = dataArray[i];
                const x = i * barWidth;
                const green = Math.min(barHeight + 100, 255);
                canvasCtx.fillStyle = `rgb(50, ${green}, 50)`;
                canvasCtx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
            }

            // Очистка и отрисовка второго спектра
            canvasCtx2.fillStyle = '#121';
            canvasCtx2.fillRect(0, 0, canvas2.width, canvas2.height);

            for (let i = 0; i < bufferLength; i++) {
                const barHeight = dataArrayAfter[i];
                const x = i * barWidth;
                const green = Math.min(barHeight + 100, 255);
                canvasCtx2.fillStyle = `rgb(50, ${green}, 50)`;
                canvasCtx2.fillRect(x, canvas2.height - barHeight, barWidth, barHeight);
            }
        }

        // Выбор "лучшего" микрофона
        async function getBestMicrophone() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const microphones = devices.filter(device => device.kind === 'audioinput' && device.deviceId !== 'default');

                if (microphones.length === 0) {
                    console.warn('Микрофоны не найдены');
                    return null;
                }

                const preferredNames = ['studio', 'pro', 'external', 'usb', 'hd'];
                const found = microphones.find(mic =>
                    preferredNames.some(name => mic.label.toLowerCase().includes(name))
                );

                if (found) return found;

                const nonDefault = microphones.find(mic => !mic.label.toLowerCase().includes('default'));
                if (nonDefault) return nonDefault;

                return microphones[0];
            } catch (error) {
                console.error('Ошибка при получении устройств:', error);
                return null;
            }
        }

        // Функция запуска аудио
        async function startAudio() {
            try {
                context = new AudioContext({sampleRate: 48000});

                const mic = await getBestMicrophone();

                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        sampleRate: 48000,
                        deviceId: mic?.deviceId || undefined,
                    }
                });

                analyser = context.createAnalyser();
                analyser.fftSize = 2048;
                analyser.minDecibels = -125;

                analyserAfter = context.createAnalyser();
                analyserAfter.fftSize = 2048;
                analyserAfter.minDecibels = -125;

                bufferLength = analyser.frequencyBinCount;

                dataArray = new Uint8Array(bufferLength);
                dataArrayAfter = new Uint8Array(bufferLength);

                canvas.width = bufferLength;
                canvas2.width = bufferLength;

                source = context.createMediaStreamSource(stream);
                source.connect(analyser);

                // Создаём каналы и чекбоксы
                nodes = channels.map(createChannel);

                // Активируем чекбоксы после инициализации
                checkboxes.forEach(cb => cb.disabled = false);

                draw();

                // Обновляем UI
                startBtn.disabled = true;
                stopBtn.disabled = false;
                statusEl.textContent = 'Running...';

            } catch (err) {
                console.error("Ошибка при запуске аудио:", err);
                alert('Не удалось запустить аудио: ' + err.message);
            }
        }

        // Функция остановки аудио
        function stopAudio() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            if (source) {
                try {
                    source.disconnect();
                } catch { }
            }
            if (analyser) {
                try {
                    analyser.disconnect();
                } catch { }
            }
            if (analyserAfter) {
                try {
                    analyserAfter.disconnect();
                } catch { }
            }
            if (context) {
                context.close();
                context = null;
            }

            // Отключаем все каналы и чекбоксы
            checkboxes.forEach(cb => {
                cb.checked = false;
                cb.disabled = true;
            });

            startBtn.disabled = false;
            stopBtn.disabled = true;
            statusEl.textContent = 'Stopped';
        }

        // Обработчики кнопок
        startBtn.addEventListener('click', startAudio);
        stopBtn.addEventListener('click', stopAudio);

        // Автоматический ресайз канвасов при изменении размера окна
        window.addEventListener('resize', () => {
            if (analyser) {
                canvas.width = analyser.frequencyBinCount;
                canvas2.width = analyser.frequencyBinCount;
            }
        });
    </script>
</body>

</html>
